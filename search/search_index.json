{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welkom bij de documentatie van GWTONN","text":"<p>Voor algemene informatie over Ge Wit't Oit Noit Nie kijk op onze website.</p>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>    mkdocs.yml    # The configuration file.\n    docs/\n        index.md  # The documentation homepage.\n        year/\n            2025/ # All about the year 2025 setup\n        gwtonn_library/ # Specific information about the general GWTONN Library support\n</code></pre>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>De volgende applicaties zijn nodig:</p> <ul> <li>VSCode: 1.98.2 of hoger</li> <li>Python</li> <li>mkdocs: &gt;= 1.6.1</li> </ul> <p>Verder worden de volgende extenties aangeraden voor VSCode:</p>"},{"location":"#github-suport","title":"GitHub Suport","text":"<ul> <li>GitHub Pull Requests</li> </ul>"},{"location":"#markdown-support","title":"Markdown support","text":"<ul> <li>Markdown All in One</li> <li>Markdown Table</li> <li>markdownlint</li> </ul>"},{"location":"#yaml-support","title":"YAML Support","text":"<ul> <li>YAML Language Support by Red Hat</li> </ul>"},{"location":"#basis-mkdocs-gebruik","title":"Basis MKDocs gebruik","text":""},{"location":"#lokaal-bekijken","title":"Lokaal bekijken","text":"<p>Voor het testen van de site gebruik de volgende commando:</p> <pre><code>.\\venv\\Scripts\\activate.ps1\nmkdocs serve\n</code></pre>"},{"location":"#documentatie-deployen","title":"Documentatie deployen","text":"<p>Om de documentatie te deployen, kan je handmatig een deploy starten:</p> <pre><code>.\\venv\\Scripts\\activate.ps1\nmkdocs gh-deploy\n</code></pre> <p>Dit script al dan een statische site maken en beschikbaar maken op de gh-pages branch.</p> <p>Waarschuwing</p> <p>Als er niet-getrackte bestanden of niet-gecommit werk zijn in de lokale repository waar <code>mkdocs gh-deploy</code> wordt uitgevoerd, zullen deze worden opgenomen in de pagina's die worden gedeployed.</p> <p>Opmerking</p> <p>Dit is niet noodzakelijk. Tijdens het mergen van een pull request gebeurt het automatisch.</p>"},{"location":"#prepareren-van-het-systeem","title":"Prepareren van het systeem","text":""},{"location":"#installeren-van-python-virtual-environment","title":"Installeren van python virtual environment","text":"<p>Voor het gebruik van mkdocs kan het best gebruik gemaakt worden van een virtuele python omgeving. Deze kan je als volgt maken:</p> <pre><code>python -m venv venv\n</code></pre> <p>Op een windows machine kan je deze activeren met:</p> <pre><code>.\\venv\\Scripts\\activate.ps1\n</code></pre> <p>Op MaOS or Linux kan je deze activeren met:</p> <pre><code>source ./venv/bin/activate\n</code></pre>"},{"location":"#installatie-mkdocs","title":"Installatie mkdocs","text":"<p>Voor het gebruik van <code>mkdocs</code> kan gebruikt worden van een virtuele python omgeving. Zie voor het opzetten van de omgeving mkdocs website</p> <pre><code>.\\venv\\Scripts\\activate.ps1\npip install -r requirements.txt\n</code></pre>"},{"location":"about/","title":"Algemene informatie","text":""},{"location":"about/#over-ge-wit-t-oit-noit-nie","title":"Over Ge Wit \u2019t Oit Noit Nie","text":"<p>Ge wit \u2019t oit noit nie is een van de wagenbouwersgroepen die sinds 1995 deelneemt aan de Brabantsedag in Heeze. Vanaf juni start ons bouwseizoen met als doel het bouwen van een prachtige, huizenhoge praalwagen. Deze wagen trekt samen met 15 andere praalwagens op de laatste zondag van augustus door de straten van Heeze. De combinatie van praalwagen, toneelspel en muziek zorgt ervoor dat het publiek vermaakt, geboeid, verblijd en soms ook ontroerd wordt. Kortom, een unieke beleving waar wij als wagenbouwersgroep zijnde graag onderdeel van uitmaken!</p>"},{"location":"about/#waarom-deze-repositories","title":"Waarom deze repositories","text":"<p>Ook binnen de Brabantsedag wordt het belangrijker dat er automatisering komt. Om hier aan tegemoet te komen, wordt er door een enthousiste groep mensen toegewerkt naar een technisch platform waarin het mogelijk is om te werken met deze automatisering.</p>"},{"location":"about/#over-het-gebruik-van-de-repositories","title":"Over het gebruik van de repositories","text":"<p>Alle code en documentatie word uitgegeven onder de MIT License. Iedere repository moet een LICENSE bestand hebben waarin dit beschreven staat.</p>"},{"location":"about/#contributors","title":"Contributors","text":"<sub>Rudi Middel</sub> <sub>Bas de Groof</sub>"},{"location":"development/","title":"Documentatie voor ontwikkeling","text":"<p>Het is belangrijk om een aantal standaarden en manieren van werken af te spreken. In deze sectie gaan we dieper in op een aantal van de conventies en afspraken.</p>"},{"location":"development/coding_conventions/","title":"Coding conventions","text":""},{"location":"development/coding_conventions/#taal","title":"Taal","text":"<p>De volgende taal is geadviseerd:</p> Onderdeel Taal Reden Source Code (+commentaar) Engels (UK) Dit is de defacto standaard. STM32 code is in Engels, voorbeelden zijn in Engels en documentation op Internet ook Documentatie (buiten source code) Nederlands Ge Wit't Oit Noit Nie is een Nederlandse lokale vereniging. Standaard taal is Nederlands. De documentatie sluit daar beter op aan"},{"location":"development/coding_conventions/#leesbaarheid","title":"Leesbaarheid","text":"<p>De code dient leesbaar geshreven te worden. Dit houdt in dat er zoveel mogelijk woorden uitgeschreven worden en geen afkortingen gebruikt worden.</p> <p>Voorbeelden:</p> <ul> <li>get_time: Correct</li> <li>gt_tm: Niet correct</li> </ul> <p>Note</p> <p>Wanneer een prefix gedaan wordt binnen een header om de functies uniek te maken, dan is dit toegestaan: <code>is_get_time</code> voor een functie binnen de <code>internal_sensor</code> header file.</p>"},{"location":"development/coding_conventions/#bestandsnamen","title":"Bestandsnamen","text":""},{"location":"development/coding_conventions/#lower_case","title":"lower_case","text":"<p>Wanneer je eigen bestanden toevoegd (zoals in de <code>docs/</code> folder), dan wordt dit altijd in lower_case gedaan.</p> <p>Waarschuwing</p> <p>Als uitzondering zijn \"CONTRIBUTING.md\", \"README.md\" en \"LICENSE\". Deze volgen een algemene conventie. Bestanden die gemaakt zijn STM32CubeMX zijn ook uitgezonderd.</p>"},{"location":"development/coding_conventions/#underscore","title":"Underscore","text":"<p>Wanneer een bestandsnaam uit meerdere woorden bestaad (zoals in dit bestand), dan wordt er altijd gebruik gemaakt van een underscore.</p>"},{"location":"development/coding_conventions/#declaraties","title":"Declaraties","text":""},{"location":"development/coding_conventions/#structure","title":"structure","text":"<p>Wanneer een structure aangemaakt wordt, dan wordt deze in lowercase geschreven. Geen toevoegingen, maar wel <code>_</code> om woorden te scheiden.</p> <pre><code>typedef struct program_controller_registers\n{\n    uint8_t instruction_pointer;\n    uint8_t shutdown_instruction_pointer;\n};\n</code></pre>"},{"location":"development/coding_conventions/#typdef-defenities","title":"typdef defenities","text":"<p>Een typedef wordt geschreven in lowercase. Tevens wordt de toevoeging <code>_t</code> gedaan om te benadrukken dat het een typedef is.</p> <pre><code>typedef struct\n{\n    uint8_t instruction_pointer;\n    uint8_t shutdown_instruction_pointer;\n} program_controller_registers_t;\n</code></pre>"},{"location":"development/coding_conventions/#enumeraties","title":"Enumeraties","text":"<p>Enumeraties worden in hoofdletters geschreven. Wanneer een typedef gemaakt wordt van een enumeratie dan wordt deze (in tegenstellign tot typedef) met hoofdtellers geschreven en zonder <code>_t</code></p> <pre><code>typedef enum\n{\n    // Control flow\n    OPCODE_HALT = 0x00,\n    OPCODE_JUMP = 0x01,\n    OPCODE_STORE_SHUTDOWN_INDEX = 0x02,\n\n    // Specific\n    OPCODE_PIN_TOGGLE = 0x10,\n    OPCODE_PIN_STATE = 0x11,\n\n    // Program related\n    OPCODE_DELAY = 0x20,\n    OPCODE_LOG_PROGRAM_STATE = 0x21,\n\n} OPCODE;\n</code></pre>"},{"location":"development/coding_conventions/#markdown","title":"Markdown","text":"<p>Voor de documentatie word gebruik gemaakt van Markdown. Meer specifiek de GitHub variant: GitHub specificatie</p> <p>Voor de callouts (WARNING, INFO, ...) wordt gebruik gemaakt van de admonitations plugin. Deze heeft een speciale manier voor het maken van de waarschuwing, informatie of voorbeeld boxen. Zie de link voor meer informatie.</p>"},{"location":"development/git/","title":"Git en GitHub","text":"<p>Voor het ontwikkelen van de software en documentatie wordt gebruik gemaakt van Git met GitHub. Door gebruik te maken van Git wordt de collaboratie beter en zijn er minder problemen met de versie.</p>"},{"location":"development/git/#standaard-afspraken","title":"Standaard afspraken","text":"<p>Om goed met git te werken, is het wel nodig een aantal afspraken te maken. De volgende lijst is een (korte) samenvatting:</p> <ul> <li>(MUST) Iedere nieuwe wens, bug of idee wordt ontwikkeled op een \"feature\" branch.</li> <li>(MUST) Wanneer de feature klaar is, dan wordt deze middels een pull-request aangeboden aan een 2de set ogen.</li> <li>(MUST) Het is niet toegestaan direct op de \"main\" branch wijzigingen te maken.</li> <li>(SHOULD) Iedere branch heeft een of meerdere \"issues\" op Github die de wijziging beschrijven.</li> </ul>"},{"location":"development/git/#github-issue-overzicht-en-aanmaken","title":"Github issue overzicht en aanmaken","text":"<p>Wanneer er een nieuwe wens is, of er een bug is, dan wordt er een issue aangemaakt in github bij het betreffende project. Indien gebruik gemaakt wordt van Github, dan kan dit in de issue tabblad:</p> <p></p> <p>Tevens kan gebruik gemaakt worden van een extentie in VSCode:</p> <p></p>"},{"location":"development/git/#minimale-gegevens","title":"Minimale gegevens","text":"<p>Het is belangrijk dat de issue minimaal de volgende gegevens heeft:</p> <ul> <li>Titel</li> <li>In geval van bug: Wat is er gebeurt om het probleem te krijgen en wat is de verwachting</li> <li>In alle andere gevallen: Wat is het gewenste gedrag / informatie nadat het issue afgehandeld heeft</li> </ul>"},{"location":"development/git/#workflow","title":"Workflow","text":"<p>De volgende workflow wort aangeraden voor het maken van wijzigingen.</p>"},{"location":"development/git/#feature-branch-maken","title":"Feature branch maken","text":"<p>Indien je een issue wil oppaken, dan kan in VSCode naast het issue op de pijl naar rechts geklikt worden. Dit maakt lokaal een nieuwe branch aan die als volgt genoemd is: [ID]-[Titel].</p> <p>Hierbij wordt ID vervangen door het nummer van het issue. Titel is uiteraard de titel van het issue. Door deze naamgeving wordt het volgen van de branches iets eenvoudiger aangezien het ID van issue herleidbaar is.</p> <p>Opmerking</p> <p>Bij het documentatie project, wordt gebruik gemaakt van ID-Titel als identifier voor een feature branch. Bij de repository 2025-software wordt gebruik gemaakt van feature/ID-Titel. Dit heeft verder geen invloed, maar het idee is dat je feature kan vervangen voor bug zodat het iets zichtbaarder is wat voor een wijziging gedaan is</p>"},{"location":"development/git/#code-commit","title":"Code commit","text":"<p>Nadat je de wijzigingen doorgevoerd hebt, kan je de gewijzigde bestanden inchecken:</p> <p></p> <p>Bij het inchecken van de wijzigingen, moet er een omschrijving opgegeven worden. In de eerste regel, gebruik maximaal 80 tekens om aan te geven waar de wijziging voor staat. Bijvoorbeeld Fixed #63: Refactor program_controller.c/.h geeft aan dat er een bestand herschreven is wat onderdeel is van issue 63.</p> <p>Vervolgens kan je een lege regel laten en uitgebreid beschrijven wat er gewijzig is. Een volledige commit heeft dan de volgende inhoud:</p> <pre><code>Fixes #10: Betere ontwikkel documentatie \n\n- Menu structuur aangepast zodat er ween kopje voor ontwikkelen hebben.\n- Git pagina gemaakt met uitleg over Git + werkwijze\n</code></pre> <p>Hierbij zie je dat er een aanpassing is geweest die een aanpassing doet op #56. Ook is beschreven waarom en wat er gewijzigd is.</p> <p>Tip</p> <p>Je schrijft de codecommit bericht voor iemand die wellicht niet weet wat de wijziging inhoud. Het is dus van belang dat de ontvangende partij moet snappen wat er gebreurt.</p> <p>Nadat de aanpassing klaar is, kan je alle wijzigingen publiceren door de feature branch te pushen naar Github. Daarna kan je een pull request aanmaken.</p> <p></p>"},{"location":"development/git/#pull-request","title":"Pull request","text":"<p>Wanneer je een of meerdere wijzigingen doorgevoerd hebt, en je bent klaar, dan ga je een pull request aanmaken. Dit kan vanuit VSCode, maar ook online.</p> <p></p> <p>Het is belangrijk dat je de pull request doorzet naar iemand anders die dan de wijzigingen kan controleren en eventueel accepteren.</p> <p></p> <p>Na het invullen van een goede beschrijving, kan je op create clicken en zal de pull request doorgezet worden. Bij het invullen kan er voor gekozen worden alvast een \"Assignee\" toe te voegen. Hiervoor dien je op het rond omcircelde knopje te drukken.</p> <p> `</p> <p>Tip</p> <p>Als je in dit scherm fouten maakt of iets vergeet en je hebt al op \"Create\" gedrukt, dan kan je altijd online nog aanpassingen maken. Ga hiervoor naar het pull requests scherm. </p>"},{"location":"gwtonn_library/","title":"Ge Wit't Oit Noit Nie bibliotheek","text":"<ul> <li>Ge Wit't Oit Noit Nie bibliotheek</li> <li>Programma controller</li> <li>Logger - FreeRTOS implementation</li> <li>Message mechanisme</li> <li>FatFS met de SD Card Controller via SPI</li> </ul> <p>Om het overzichtelijk te houden, is er een losse bibliotheek gemaakt voor Ge Wit't Oit Noit Nie. De bibliotheek is te vinden in <code>{workspace}/Middlewares/gwtonn</code>.</p>"},{"location":"gwtonn_library/#programma-controller","title":"Programma controller","text":"<p>Voor het uitvoeren van de programma, is er een programma controller. De details staan beschreven in programma.md.</p>"},{"location":"gwtonn_library/#logger-freertos-implementation","title":"Logger - FreeRTOS implementation","text":"<p>De <code>logger</code> implementeerd functionaliteiten om een log te schrijven op een SD kaart (Via de SPI Interface).</p> <p>De <code>void start_logger(void *argument)</code> is geimplementeerd in the bilbiotheek. De functie is <code>__weak</code> gemaakt in <code>freertos.c</code>. Om dit te laten werken, is in de STM32CubeMX programma een FreeRTOS taak gemaakt met de naam logTask en de functie <code>start_logger</code>. De Code Generation Option is ingesteld op As Weak.</p> <p>Voor details over de logger, kijk in de hoofdstuk over de logger.</p>"},{"location":"gwtonn_library/#message-mechanisme","title":"Message mechanisme","text":"<p>Om een berichte te schrijven op de SD kaart, kan een specifieke wachtrij gevuld worden. Deze rij heet loggerQueue. De queue wordt uitmatisch gemaakt bij het schrijven van de broncode vanuit STM32CubeMX.</p> <p>Om een bericht te sturen moet je <code>sd_logger.h</code> laden in de c code. Daarna kan de volgende code toegevoegd worden:</p> <pre><code> MSGQUEUE_OBJ_t msg;\n\nmsg.index=1;\nmsg.message = 'A';\nosMessageQueuePut(loggerQueueHandle, &amp;msg, 0, 0U);\n</code></pre>"},{"location":"gwtonn_library/#fatfs-met-de-sd-card-controller-via-spi","title":"FatFS met de SD Card Controller via SPI","text":"<p>Om bestanden te kunnen maken op een SD kaart, gebruiken we een SD Card reader. Deze wordt aangesloten via een SPI Interface met de Nucleo board. Vervolgens gebruiken we de FatFS library om een bestandsysteem te simuleren.</p> <p>De FatFS staat aangemerkt als <code>USER_Driver</code> in STM32CubeMX. Deze userdriver is gedefineerd in user_diskio.h en geimplementeerd in  user_diskio.c.</p> <p>De vertaalslag van de FATFS implentatie naar SPI commando's gebeurt in fatfs_sd.c.</p>"},{"location":"gwtonn_library/logger/","title":"Logger","text":"<p>De logger wordt gebruikt om cruciale informatie op te slaan over de staat van de STM32 en het programma.</p>"},{"location":"gwtonn_library/logger/#voorbeeld","title":"Voorbeeld","text":"<p>Kijk naar de volgende entry:</p> <pre><code>[13:18:16],16,3,9,64100,149\n</code></pre> <p>De volgende gegevens worden weergegeven:</p> <ul> <li>[13:18:16]: Tijd van het bericht</li> <li>16: Bericht soort (MSG_PROGRAM_COUNTER)</li> <li>3: instruction_pointer op moment van loggen</li> <li>9: shutdown_index op moment van loggen</li> <li>64100: Interne temperatuur van de STM32</li> <li>149: Actuele voltage op moment van schrijven van de STM32</li> </ul>"},{"location":"gwtonn_library/logger/#logbericht-sturen","title":"Logbericht sturen","text":"<p>Om een bericht te loggen dient er een bericht op de queue gezet te worden. Volgende stukje code is een voorbeeld:</p> <pre><code>MSGQUEUE_OBJ_t msg = {\n    MSG_PROGRAM_COUNTER,\n    pcr.instruction_pointer,\n    pcr.shutdown_instruction_pointer,\n    get_temperature(),\n    get_vref(),\n    };\nif (osOK != osMessageQueuePut(loggerQueueHandle, &amp;msg, 0, 0U))\n{\n    printf(\"Error: Could not send message to loggerQueueHandle\\n\\r\");\n}\n</code></pre> <p>Zoals je kan zien wordt er eerst een bericht aangemaakt. Daarna wordt deze op de queue gezet (<code>loggerQueueHandle</code>). Voor de exacte details van het queue mechanisme kan je kijken bij ST.</p>"},{"location":"gwtonn_library/logger/#log-bericht","title":"Log bericht","text":"<p>Voor het versturen van een log bericht wordt gebruik gemaakt van een structure. </p> <pre><code>typedef struct\n{\n    uint8_t message;\n    uint32_t program_counter;\n    uint16_t shutdown_index_register;\n    uint16_t temperature;\n    uint16_t vrefint;\n} MSGQUEUE_OBJ_t;\n</code></pre> <p>Hiervoor geld de volgende definitie:</p> Kolom Type Omschrijving message uint8_t Een waarde die aangeeft wat het bericht betekened (MSG_PROGRAM_COUNTER) program_counter uint32_t De huidige waare van de instruction_pointer shutdown_index_register uint16_t De huidige waarde van de shutdown_index_register temperature uint16_t De huidige temperatuur van de STM32 in graden celcius * 1000 vrefint uint16_t De huidige voltage van de STM32 in mV"},{"location":"gwtonn_library/programma/","title":"Programma","text":"<p>Het hele idee van de controller is om een progarmma uit te voeren. Om dit flexibel te maken, is er een basis instructieset gemaakt. Met deze instructieset kan een programma gemaakt worden.</p>"},{"location":"gwtonn_library/programma/#programmeren","title":"Programmeren","text":"<p>Maak een bestand met de naam \"programma.h\" en plaats hierin het programma. Zie voorbeeld programma voor een voorbeeld. Ieder programma moet minimaal een <code>OPCODE_HALT</code> regel bevatten.</p> <p>Het programma wordt weggeschreven in een vast stukje van het geheugen. Dit wordt uitgelegd in het hoofdstuk geheugen</p> <p>We hebben te maken met een 32-bit system, daarom kunnen we uitgaan van de volgende grote:</p> <ul> <li><code>OPCODE</code>: 4 bytes</li> <li><code>void *</code>: 4 bytes</li> </ul> <p>Dus de grootte van de struct, voordat eventuele padding wordt toegepast, is: OPCODE + (3 x VOID) = 16 bytes*.</p> <p>Voor een array met 255 elementen, is de totale benodigde grootte: 255 * 16 = 4080 bytes.</p>"},{"location":"gwtonn_library/programma/#instuctieset","title":"Instuctieset","text":"<p>Een programma kan gemaakt worden door het opzetten van een instructie set. De onderstaande tabel bevat een overzicht van de functies.</p> Functie OpCode Parameter 0 Parameter 1 Parameter 2 Omschrijving OPCODE_HALT 0x00 Stop met het uitvoeren van de programma. OPCODE_JUMP 0x01 index (0-bound) van de volgende instructie Laat het programma \"springen\" naar de instructie met index Parameter0 OPCODE_STORE_SHUTDOWN_INDEX 0x02 Index waar het programma naar toe moet om af te sluiten (0-bound) Laat het programma \"spingen\" naar deze positie als de pauze trigger gedaan wordt. OPCODE_PIN_TOGGLE 0x10 GPIOx \u2013 Where x can be (A..K) to select the GPIO peripheral for STM32F429X device or x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices GPIO_Pin \u2013 Specifies the pins to be toggled. Zet een pin op hoog als deze laag is; Zet een pin op laag als deze hoog is. OPCODE_PIN_STATE 0x11 GPIOx \u2013 Where x can be (A..K) to select the GPIO peripheral for STM32F429X device or x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices GPIO_Pin \u2013 Specifies the pins to be toggled GPIO_PIN_SET of GPIO_PIN_RESET Zet de status van een pin OPCODE_DELAY 0x20 De gewenste delay in MS Laat het programma wachten voor x ms OPCODE_LOG_PROGRAM_STATE 0x21 n/a Stuur de huidige status van het programma (alle registers) naar de log"},{"location":"gwtonn_library/programma/#geheugen","title":"Geheugen","text":"<p>Voor het verwerken van het progamma heeft de firmware een stukje geheugen gereserveerd. Op de STM32F412xG zijn 11 sectoren in het geheugen aanwezig. Voor onze firmware reserveren we een sector om het programm in op te slaan. Door een hele sector te reserveren kunnen we Over-the-Air updates of updates vanaf de SD Card beter uitvoeren.</p> <p>Binnen de F412xG zijn de eerste 5 sectoren 64Kb per stuk. De andere sectoren zijn 128Kb per stuk. Aangezien we ons programm aan het einde willen opslaan in de firmware, betekend dit dat we 128Kb tot onze beschikking hebben.</p> <p>In de linker script is dit terug te vinden:</p> <pre><code>MEMORY\n{\n    RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 256K\n    FLASH (rx)     : ORIGIN = 0x08000000, LENGTH = 1024K - 128k\n    RESERVED (rw)  : ORIGIN = 0x080E0000, LENGTH = 128k\n}\n  .program_data_block :\n  {\n    . = ALIGN(4);\n    FILL(0x00)\n    *(.program_data_block)\n    . = ALIGN(4);\n  } &gt; RESERVED \n</code></pre>"},{"location":"gwtonn_library/programma/#geheugen-vulling","title":"Geheugen vulling","text":"<p>Bij het reserveren van de sector (zie vorige paragraaf) wordt het geheugen gevult met 0x00. Doordat de HALT instructie de waarde 0x00 heeft, zal effectief het hele geheugen dus vol staan met HALT (totdat er een programma geladen wordt).</p>"},{"location":"gwtonn_library/programma/#data-gebruik","title":"Data gebruik","text":"<p>Na het linken van de code, wordt er een overzicht gegeven van het geheugen en de grote. De volgende 3 regio's zijn aanwezig:</p> <ul> <li>RAM</li> <li>FLASH</li> <li>RESERVED</li> </ul> <p>Het programma wordt opgeslagen in het <code>RESERVED</code> blok. De volledige block is beschikbaar voor het maken van een programma.</p> <p>Voorbeeld van een output. In deze output is te zien dat 5.49% gebruikt is.</p> <pre><code>[build] Memory region         Used Size  Region Size  %age Used\n[build]              RAM:       25872 B       256 KB      9.87%\n[build]            FLASH:       55824 B    1044496 B      5.34%\n[build]         RESERVED:         224 B       4080 B      5.49%\n</code></pre>"},{"location":"gwtonn_library/programma/#voorbeeld-programma","title":"Voorbeeld programma","text":""},{"location":"gwtonn_library/programma/#simple-programma-om-de-blauwe-led-te-knipperen","title":"Simple programma om de blauwe led te knipperen","text":"<p>Declareer de blauwe led met <code>BLUE_LED_Pin</code> en zorg dat deze op <code>BLUE_LED_GPIO_Port</code> gemount zit.</p> <pre><code>#ifndef __PROGRAMMA_H__\n#define __PROGRAMMA_H__\n\n#include &lt;program_controller.h&gt;\n#include &lt;main.h&gt;\n\nvolatile MEM_PROGRAM_DATA_BLOCK instruction_t instruction[] = {\n    {.opcode = OPCODE_PIN_STATE, .parameter0 = (void *)BLUE_LED_Pin, .parameter1 = (void *)BLUE_LED_GPIO_Port, .parameter2 = (void *)GPIO_PIN_SET},\n    {.opcode = OPCODE_DELAY, .parameter0 = (void *)1500},\n    {.opcode = OPCODE_PIN_TOGGLE, .parameter0 = (void *)BLUE_LED_Pin, .parameter1 = (void *)BLUE_LED_GPIO_Port},\n    {.opcode = OPCODE_JUMP, .parameter0 = (void *)1},\n    {.opcode = OPCODE_HALT},\n};\n\n#endif // __PROGRAMMA_H__\n</code></pre>"},{"location":"year/2025/about/","title":"Over 2025","text":"<p>Hier komt een beschrijving van de setup voor 2025.</p>"},{"location":"year/2025/about/#hardware-setup","title":"Hardware setup","text":"<p>[!NOTE] Maak een schema met de verschillende componenten</p>"},{"location":"year/2025/about/#component-1","title":"Component 1","text":""},{"location":"year/2025/about/#component-2","title":"Component 2","text":""},{"location":"year/2025/about/#programma","title":"Programma","text":"<p>Beschrijf hier de programma die uitgevoerd moet worden in simpele stappen.</p> <p>Voeg eventueel een tekening toe met uml:</p> <pre><code>@startuml\n\nstart\n  :store exit index;\nrepeat\n  :zet motor in vooruit;\n  :start motor;\n  :wacht voor 3 seconden;\n  :stop motor;\n  :wacht voor 4 seconden;\n  :zet motor in reverse;\n  :start motor;\n  :wacht voor 3 seconden;\n  :stop motor;\nrepeat while (more data?) is (yes) not (no)\n  :zet motor in reverse;\n  :start motor;\n  :wacht voor 4 seconden;\n  :stop motor;\n\nstop\n@enduml\n</code></pre>"},{"location":"year/2025/program_specifications/","title":"Programnma specificaties","text":""},{"location":"year/2025/program_specifications/#pins-functies","title":"Pins &amp; Functies","text":"<ul> <li>USART3: Serial port voor sturen van informatie</li> <li>SYS: Debug: Serial wire, Timebase Source: TIM1</li> <li>RCC: High speed clock and low speed clock based on cristals build in  </li> <li>SPI1: SD Card writer over SPI</li> <li>EXTI line 1: Voor interrupt</li> <li>EXTI line 15: Voor interrupt</li> </ul>"},{"location":"year/2025/program_specifications/#pins","title":"PINS","text":"PIN Assignment PA4 SPI1_CS PA5 SPI1_SCK PA6 SPI1_MISO PA7 SPI1_MOSI PA13 SYS_JTMS-SWDIO PA14 SYS_JTMS-SWCLK PB0 LED 1 [Green] - DefaultTask running PB1 GPIO External Interrupt mode with Rise Edge trigger detection - Emergency button PB3 SYT_JTDO-SWO PB7 LED 2 [Blue] PB14 LED 3 [Red] - HardFault_Handler entered PC14 RCC_OSC32 PC15 RCC_OSC32_OUT PD8 UART3_TX PD9 UART3_RX PH0 RCC_OSC_IN PH1 RCC_OSC_OUT"}]}