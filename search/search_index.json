{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welkom bij Ge Wit \u2019t Oit Noit Nie","text":"<p>Ge wit \u2019t oit noit nie is een van de wagenbouwersgroepen die sinds 1995 deelneemt aan de Brabantsedag in Heeze. Vanaf juni start ons bouwseizoen met als doel het bouwen van een prachtige, huizenhoge praalwagen. Deze wagen trekt samen met 15 andere praalwagens op de laatste zondag van augustus door de straten van Heeze. De combinatie van praalwagen, toneelspel en muziek zorgt ervoor dat het publiek vermaakt, geboeid, verblijd en soms ook ontroerd wordt. Kortom, een unieke beleving waar wij als wagenbouwersgroep zijnde graag onderdeel van uitmaken!</p>"},{"location":"#waarom-deze-repositories","title":"Waarom deze repositories","text":"<p>Ook binnen de Brabantsedag wordt het belangrijker dat er automatisering komt. Om hier aan tegemoet te komen, wordt er door een enthousiste groep mensen toegewerkt naar een technisch platform waarin het mogelijk is om te werken met deze automatisering.</p>"},{"location":"#site-structuur","title":"Site structuur","text":"<p>De volgende belangrijke onderdelen zijn beschreven:</p> <ul> <li>Hardware</li> <li>Software</li> <li>Guidelines &amp; handleidingen</li> </ul>"},{"location":"#over-het-gebruik-van-de-repositories","title":"Over het gebruik van de repositories","text":"<p>Alle code en documentatie word uitgegeven onder de MIT License. Iedere repository moet een LICENSE bestand hebben waarin dit beschreven staat.</p>"},{"location":"#contributors","title":"Contributors","text":"<sub>Rudi Middel</sub> <sub>Bas de Groof</sub>"},{"location":"site_structure/","title":"Welkom bij de documentatie van GWTONN","text":"<p>Voor algemene informatie over Ge Wit't Oit Noit Nie kijk op onze website.</p>"},{"location":"site_structure/#project-layout","title":"Project layout","text":"<pre><code>    mkdocs.yml    # The configuration file.\n    docs/\n        index.md  # The documentation homepage.\n        year/\n            2025/ # All about the year 2025 setup\n        gwtonn_library/ # Specific information about the general GWTONN Library support\n</code></pre>"},{"location":"site_structure/#prerequisites","title":"Prerequisites","text":"<p>De volgende applicaties zijn nodig:</p> <ul> <li>VSCode: 1.98.2 of hoger</li> <li>Python</li> <li>mkdocs: &gt;= 1.6.1</li> </ul> <p>Verder worden de volgende extenties aangeraden voor VSCode:</p>"},{"location":"site_structure/#github-suport","title":"GitHub Suport","text":"<ul> <li>GitHub Pull Requests</li> </ul>"},{"location":"site_structure/#markdown-support","title":"Markdown support","text":"<ul> <li>Markdown All in One</li> <li>Markdown Table</li> <li>markdownlint</li> </ul>"},{"location":"site_structure/#yaml-support","title":"YAML Support","text":"<ul> <li>YAML Language Support by Red Hat</li> </ul>"},{"location":"site_structure/#basis-mkdocs-gebruik","title":"Basis MKDocs gebruik","text":""},{"location":"site_structure/#lokaal-bekijken","title":"Lokaal bekijken","text":"<p>Voor het testen van de site gebruik de volgende commando:</p> <pre><code>.\\venv\\Scripts\\activate.ps1\nmkdocs serve\n</code></pre>"},{"location":"site_structure/#documentatie-deployen","title":"Documentatie deployen","text":"<p>Om de documentatie te deployen, kan je handmatig een deploy starten:</p> <pre><code>.\\venv\\Scripts\\activate.ps1\nmkdocs gh-deploy\n</code></pre> <p>Dit script al dan een statische site maken en beschikbaar maken op de gh-pages branch.</p> <p>Waarschuwing</p> <p>Als er niet-getrackte bestanden of niet-gecommit werk zijn in de lokale repository waar <code>mkdocs gh-deploy</code> wordt uitgevoerd, zullen deze worden opgenomen in de pagina's die worden gedeployed.</p> <p>Opmerking</p> <p>Dit is niet noodzakelijk. Tijdens het mergen van een pull request gebeurt het automatisch.</p>"},{"location":"site_structure/#prepareren-van-het-systeem","title":"Prepareren van het systeem","text":""},{"location":"site_structure/#installeren-van-python-virtual-environment","title":"Installeren van python virtual environment","text":"<p>Voor het gebruik van mkdocs kan het best gebruik gemaakt worden van een virtuele python omgeving. Deze kan je als volgt maken:</p> <pre><code>python -m venv venv\n</code></pre> <p>Op een windows machine kan je deze activeren met:</p> <pre><code>.\\venv\\Scripts\\activate.ps1\n</code></pre> <p>Op MaOS or Linux kan je deze activeren met:</p> <pre><code>source ./venv/bin/activate\n</code></pre>"},{"location":"site_structure/#installatie-mkdocs","title":"Installatie mkdocs","text":"<p>Voor het gebruik van <code>mkdocs</code> kan gebruikt worden van een virtuele python omgeving. Zie voor het opzetten van de omgeving mkdocs website</p> <pre><code>.\\venv\\Scripts\\activate.ps1\npip install -r requirements.txt\n</code></pre>"},{"location":"guidelines/","title":"Documentatie voor ontwikkeling","text":"<p>Het is belangrijk om een aantal standaarden en manieren van werken af te spreken. In deze sectie gaan we dieper in op een aantal van de conventies en afspraken.</p>"},{"location":"guidelines/coding_conventions/","title":"Coding conventions","text":""},{"location":"guidelines/coding_conventions/#taal","title":"Taal","text":"<p>De volgende taal is geadviseerd:</p> Onderdeel Taal Reden Source Code (+commentaar) Engels (UK) Dit is de defacto standaard. STM32 code is in Engels, voorbeelden zijn in Engels en documentation op Internet ook Documentatie (buiten source code) Nederlands Ge Wit't Oit Noit Nie is een Nederlandse lokale vereniging. Standaard taal is Nederlands. De documentatie sluit daar beter op aan"},{"location":"guidelines/coding_conventions/#leesbaarheid","title":"Leesbaarheid","text":"<p>De code dient leesbaar geshreven te worden. Dit houdt in dat er zoveel mogelijk woorden uitgeschreven worden en geen afkortingen gebruikt worden.</p> <p>Voorbeelden:</p> <ul> <li>get_time: Correct</li> <li>gt_tm: Niet correct</li> </ul> <p>Note</p> <p>Wanneer een prefix gedaan wordt binnen een header om de functies uniek te maken, dan is dit toegestaan: <code>is_get_time</code> voor een functie binnen de <code>internal_sensor</code> header file.</p>"},{"location":"guidelines/coding_conventions/#bestandsnamen","title":"Bestandsnamen","text":""},{"location":"guidelines/coding_conventions/#lower_case","title":"lower_case","text":"<p>Wanneer je eigen bestanden toevoegd (zoals in de <code>docs/</code> folder), dan wordt dit altijd in lower_case gedaan.</p> <p>Waarschuwing</p> <p>Als uitzondering zijn \"CONTRIBUTING.md\", \"README.md\" en \"LICENSE\". Deze volgen een algemene conventie. Bestanden die gemaakt zijn STM32CubeMX zijn ook uitgezonderd.</p>"},{"location":"guidelines/coding_conventions/#underscore","title":"Underscore","text":"<p>Wanneer een bestandsnaam uit meerdere woorden bestaad (zoals in dit bestand), dan wordt er altijd gebruik gemaakt van een underscore.</p>"},{"location":"guidelines/coding_conventions/#declaraties","title":"Declaraties","text":""},{"location":"guidelines/coding_conventions/#structure","title":"structure","text":"<p>Wanneer een structure aangemaakt wordt, dan wordt deze in lowercase geschreven. Geen toevoegingen, maar wel <code>_</code> om woorden te scheiden.</p> <pre><code>typedef struct program_controller_registers\n{\n    uint8_t instruction_pointer;\n    uint8_t shutdown_instruction_pointer;\n};\n</code></pre>"},{"location":"guidelines/coding_conventions/#typdef-defenities","title":"typdef defenities","text":"<p>Een typedef wordt geschreven in lowercase. Tevens wordt de toevoeging <code>_t</code> gedaan om te benadrukken dat het een typedef is.</p> <pre><code>typedef struct\n{\n    uint8_t instruction_pointer;\n    uint8_t shutdown_instruction_pointer;\n} program_controller_registers_t;\n</code></pre>"},{"location":"guidelines/coding_conventions/#enumeraties","title":"Enumeraties","text":"<p>Enumeraties worden in hoofdletters geschreven. Wanneer een typedef gemaakt wordt van een enumeratie dan wordt deze (in tegenstellign tot typedef) met hoofdtellers geschreven en zonder <code>_t</code></p> <pre><code>typedef enum\n{\n    // Control flow\n    OPCODE_HALT = 0x00,\n    OPCODE_JUMP = 0x01,\n    OPCODE_STORE_SHUTDOWN_INDEX = 0x02,\n\n    // Specific\n    OPCODE_PIN_TOGGLE = 0x10,\n    OPCODE_PIN_STATE = 0x11,\n\n    // Program related\n    OPCODE_DELAY = 0x20,\n    OPCODE_LOG_PROGRAM_STATE = 0x21,\n\n} OPCODE;\n</code></pre>"},{"location":"guidelines/coding_conventions/#markdown","title":"Markdown","text":"<p>Voor de documentatie word gebruik gemaakt van Markdown. Meer specifiek de GitHub variant: GitHub specificatie</p> <p>Voor de callouts (WARNING, INFO, ...) wordt gebruik gemaakt van de admonitations plugin. Deze heeft een speciale manier voor het maken van de waarschuwing, informatie of voorbeeld boxen. Zie de link voor meer informatie.</p>"},{"location":"guidelines/git/","title":"Git en GitHub","text":"<p>Voor het ontwikkelen van de software en documentatie wordt gebruik gemaakt van Git met GitHub. Door gebruik te maken van Git wordt de collaboratie beter en zijn er minder problemen met de versie.</p>"},{"location":"guidelines/git/#standaard-afspraken","title":"Standaard afspraken","text":"<p>Om goed met git te werken, is het wel nodig een aantal afspraken te maken. De volgende lijst is een (korte) samenvatting:</p> <ul> <li>(MUST) Iedere nieuwe wens, bug of idee wordt ontwikkeled op een \"feature\" branch.</li> <li>(MUST) Wanneer de feature klaar is, dan wordt deze middels een pull-request aangeboden aan een 2de set ogen.</li> <li>(MUST) Het is niet toegestaan direct op de \"main\" branch wijzigingen te maken.</li> <li>(SHOULD) Iedere branch heeft een of meerdere \"issues\" op Github die de wijziging beschrijven.</li> </ul>"},{"location":"guidelines/git/#github-issue-overzicht-en-aanmaken","title":"Github issue overzicht en aanmaken","text":"<p>Wanneer er een nieuwe wens is, of er een bug is, dan wordt er een issue aangemaakt in github bij het betreffende project. Indien gebruik gemaakt wordt van Github, dan kan dit in de issue tabblad:</p> <p></p> <p>Tevens kan gebruik gemaakt worden van een extentie in VSCode:</p> <p></p>"},{"location":"guidelines/git/#minimale-gegevens","title":"Minimale gegevens","text":"<p>Het is belangrijk dat de issue minimaal de volgende gegevens heeft:</p> <ul> <li>Titel</li> <li>In geval van bug: Wat is er gebeurt om het probleem te krijgen en wat is de verwachting</li> <li>In alle andere gevallen: Wat is het gewenste gedrag / informatie nadat het issue afgehandeld heeft</li> </ul>"},{"location":"guidelines/git/#workflow","title":"Workflow","text":"<p>De volgende workflow wort aangeraden voor het maken van wijzigingen.</p>"},{"location":"guidelines/git/#feature-branch-maken","title":"Feature branch maken","text":"<p>Indien je een issue wil oppaken, dan kan in VSCode naast het issue op de pijl naar rechts geklikt worden. Dit maakt lokaal een nieuwe branch aan die als volgt genoemd is: [ID]-[Titel].</p> <p>Hierbij wordt ID vervangen door het nummer van het issue. Titel is uiteraard de titel van het issue. Door deze naamgeving wordt het volgen van de branches iets eenvoudiger aangezien het ID van issue herleidbaar is.</p> <p>Opmerking</p> <p>Bij het documentatie project, wordt gebruik gemaakt van ID-Titel als identifier voor een feature branch. Bij de repository 2025-software wordt gebruik gemaakt van feature/ID-Titel. Dit heeft verder geen invloed, maar het idee is dat je feature kan vervangen voor bug zodat het iets zichtbaarder is wat voor een wijziging gedaan is</p>"},{"location":"guidelines/git/#code-commit","title":"Code commit","text":"<p>Nadat je de wijzigingen doorgevoerd hebt, kan je de gewijzigde bestanden inchecken:</p> <p></p> <p>Bij het inchecken van de wijzigingen, moet er een omschrijving opgegeven worden. In de eerste regel, gebruik maximaal 80 tekens om aan te geven waar de wijziging voor staat. Bijvoorbeeld Fixed #63: Refactor program_controller.c/.h geeft aan dat er een bestand herschreven is wat onderdeel is van issue 63.</p> <p>Vervolgens kan je een lege regel laten en uitgebreid beschrijven wat er gewijzig is. Een volledige commit heeft dan de volgende inhoud:</p> <pre><code>Fixes #10: Betere ontwikkel documentatie \n\n- Menu structuur aangepast zodat er ween kopje voor ontwikkelen hebben.\n- Git pagina gemaakt met uitleg over Git + werkwijze\n</code></pre> <p>Hierbij zie je dat er een aanpassing is geweest die een aanpassing doet op #56. Ook is beschreven waarom en wat er gewijzigd is.</p> <p>Tip</p> <p>Je schrijft de codecommit bericht voor iemand die wellicht niet weet wat de wijziging inhoud. Het is dus van belang dat de ontvangende partij moet snappen wat er gebreurt.</p> <p>Nadat de aanpassing klaar is, kan je alle wijzigingen publiceren door de feature branch te pushen naar Github. Daarna kan je een pull request aanmaken.</p> <p></p>"},{"location":"guidelines/git/#pull-request","title":"Pull request","text":"<p>Wanneer je een of meerdere wijzigingen doorgevoerd hebt, en je bent klaar, dan ga je een pull request aanmaken. Dit kan vanuit VSCode, maar ook online.</p> <p></p> <p>Het is belangrijk dat je de pull request doorzet naar iemand anders die dan de wijzigingen kan controleren en eventueel accepteren.</p> <p></p> <p>Na het invullen van een goede beschrijving, kan je op create clicken en zal de pull request doorgezet worden. Bij het invullen kan er voor gekozen worden alvast een \"Assignee\" toe te voegen. Hiervoor dien je op het rond omcircelde knopje te drukken.</p> <p> `</p> <p>Tip</p> <p>Als je in dit scherm fouten maakt of iets vergeet en je hebt al op \"Create\" gedrukt, dan kan je altijd online nog aanpassingen maken. Ga hiervoor naar het pull requests scherm. </p>"},{"location":"guidelines/hardware/","title":"Hardware","text":""},{"location":"guidelines/hardware/#ontwerp-programma-hardware","title":"Ontwerp programma hardware","text":""},{"location":"guidelines/hardware/#printplaat","title":"Printplaat","text":"<p>Voor het ontwerp van de printplaat word gebruik gemaakt van het gratis programma KiCAD. Dit is een printplaat ontwerp programma met ruime functionaliteit die voldoet aan al onze eisen. Een handleiding hiervoor staat in het engels beschreven in deze link.</p>"},{"location":"guidelines/hardware/#technische-specificatie","title":"Technische specificatie","text":"<p>De microcontroller die gekozen is voor het project is de STM32F412RGT6 van ST Microelectronics. Deze chip heeft genoeg ruimte en besturingsmogelijkheden om voldoende programma's van komende jaren met gemak te kunnen draaien. Daarnaast bevat deze chip meerdere communicatiemogelijkheden die in de toekomst gebruikt kunnen worden.</p>"},{"location":"guidelines/hardware/#klokken-van-de-microcontroller","title":"Klokken van de microcontroller","text":"<p>Een klok binnen een microcontroller zorgt voor coordinatie van vercheidene operaties. Er kunnen per microcontroller meerdere klokken gebruikt worden, binnen dit project worden er twee gebruikt.</p>"},{"location":"guidelines/hardware/#hoge-snelheids-extern-kristal-hse","title":"Hoge Snelheids Extern kristal (HSE)","text":"<p>Voor het Hoge Snelheids Extern kristal (HSE) word momenteel een 8 MHz resonator gebruikt. Deze zijn niet duur en bieden meer precisie dan de ingebouwde RC klok. Een standaard integratie is te zien in de hieropvolgende afbeelding.</p> <p> Meer informatie over een fatsoenlijke layout en integratie is te vinden in AN2867 \u201cOscillator design guide for ST microcontrollers\", beschikbaar via de website van ST-Microelectronics. </p> <p>Mocht er gekozen worden voor het gebruik van de interne clock, kan de plaatsing van de relevante componenten tijdens de print assemblage overgeslagen worden.  Stel dat de klok het niet doet na verandering van het component kan eventueel de externe weerstand (R<sub>EXT</sub> in bovenstaande afbeelding) naar 0 \u03a9 gezet worden.</p>"},{"location":"guidelines/hardware/#huidig-component-in-gebruik","title":"Huidig component in gebruik","text":"<p>Momenteel word gebruik van de Kitelco 8 MHz SX-1T&amp;RC16 gemaakt. Dit is een 8 MHz resonator met aan weerskanten laad condensatoren van 16 pF, die zorgen voor verbeterde stabiliteit van het signaal. Daarnaast is de externe weerstand (R<sub>EXT</sub> in bovenstaande afbeelding) berekend op 1.2 k\u03a9 via sectie 3.5.3 van AN2867.</p> <p>Indien dit in de toekomst verandert moet er opnieuw via de datasheet van het nieuwe component gekeken worden naar de laad condensatoren en naar de externe weerstand. </p>"},{"location":"guidelines/hardware/#real-time-clock-kristal-rtc","title":"Real-Time Clock kristal (RTC)","text":"<p>Voor de RTC is een externe clock gewenst en in gebruik, omdat deze meer precisie bied qua dingen die op tijd basis gaan. Deze moet een frequentie hebben van 32.768 kHz, wat een industrie standaard is. Hieronder is een standaard integratie weergegeven.</p> <p></p> <p>Meer informatie over een fatsoenlijke layout en integratie is te vinden in AN2867 \u201cOscillator design guide for ST microcontrollers\", beschikbaar via de website van ST-Microelectronics.</p>"},{"location":"guidelines/hardware/#huidig-component-in-gebruik_1","title":"Huidig component in gebruik","text":"<p>Momenteel word gebruik van de YIC 32.768K12.5PI/MC306 gemaakt. Dit is een 32.768 kHz resonator met aan weerskanten laad condensatoren van 7 pF, die zorgen voor verbeterde stabiliteit van het signaal.</p> <p>Indien dit in de toekomst verandert moet er opnieuw via de datasheet van het nieuwe component gekeken worden naar de laad condensatoren. LET OP: Dit component heeft een niet standaard footprint in KiCAD.</p>"},{"location":"guidelines/hardware/#programmeren-via-swd","title":"Programmeren via SWD","text":"<p>Voor het programmeren van de STM32 word een STLINK/V2 gebruikt. Deze heeft de volgende pinconfiguratie beschikbaar:</p> <p></p> <p>Voor het programmeren van de microcontroller moeten de volgende pinnen aangesloten zijn op de volgende manier:</p> <ol> <li>GND<sub>STLINK</sub> naar GND<sub>STM32</sub></li> <li>VDD<sub>STLINK</sub> naar 3V3<sub>STM32</sub></li> <li>SWDIO<sub>STLINK</sub> naar SWDIO<sub>STM32</sub></li> <li>SWCLK<sub>STLINK</sub> naar SWCLK<sub>STM32</sub></li> <li>MCU VDD <sub>STLINK</sub> (ookwel VDUT genoemd) naar 3V3<sub>STM32</sub></li> </ol>"},{"location":"guidelines/hardware/#externe-voeding","title":"Externe voeding","text":"<p>Indien de STLINK/V2 op zichzelf niet genoeg stroom levert kan er een externe voeding gebruikt worden in combinatie met de hierbovenstaande pinconfiguratie. LET OP: sluit niets met een spanning hoger dan 3.3 V aan op de 3V3 poort, dit kan schade aan de basismodule of STLINK toebrengen! Verifieer dit voor het aansluiten met een multimeter.</p>"},{"location":"guidelines/hardware/#voeding-van-5-v-tot-30-v","title":"Voeding van 5 V tot 30 V","text":"<p>De positieve pool van deze voeding moet aangesloten worden op de VIN pin en de negatieve pool op de GND pin. Beide pinnen zijn te vinden op de normale snelheidsbus (Regular I/O). De desbetreffende pinnen zijn te vinden onder het kopje Hardware.</p>"},{"location":"guidelines/hardware/#voeding-van-33-v","title":"Voeding van 3.3 V","text":"<p>De positieve pool moet op een van de 3V3 pinnen terecht komen via de voeding zelf of het STM32 bord. De negatieve pool kan verbonden worden met een GND pin op de basismodule of de STLINK/V2. Deze pinnen zijn op de basismodule gemarkeerd.</p>"},{"location":"gwtonn_hardware/bus/","title":"Bus architectuur","text":"<p>Er is voor een bus architectuur gekozen waarbij alle benodigde draden in een kabel gecombineerd zijn. Een bus architectuur gebruikt minimale bekabeling waarbij alle apparaten in een lijn aan elkaar zitten met een kop aan de ene kant en een staart aan de andere kant, zoals te zien is op de afbeelding hieronder. Hiervoor is gekozen zodat er zo min mogelijk losse kabels door de wagen gaan.</p> <p></p> <p>Deze bus architectuur is galvanisch geisoleerd tot alle individuele modules tot 2 kV, waardoor een module die aan de bus hangt catastrofaal kan falen zonder de rest van het netwerk mee te nemen.</p>"},{"location":"gwtonn_hardware/bus/#fysieke-laag","title":"Fysieke laag","text":"<p>De fysieke aansluiting van de bus is een CAT-5 kabel. Over deze kabel gaan de volgende signalen:</p> <ul> <li>CAN</li> <li>Spanning</li> <li>Noodstop</li> </ul> <p>De draad functies worden hieronder gegeven.</p> draadnummer kleur functie 1 wit/groen CAN positief 2 groen CAN negatief 3 wit/oranje Noodstop positief 4 blauw Spanning 5 wit/blauw Spanning 6 oranje Noodstop negatief 7 wit/bruin Aarde 8 bruin Aarde"},{"location":"gwtonn_hardware/bus/#aansluitingen","title":"Aansluitingen","text":""},{"location":"gwtonn_hardware/bus/#can","title":"CAN","text":"<p>CAN is een automotive communicatie standaard die bekend staat om zijn robuustheid. Het heeft een positieve en negatieve draad nodig die het liefst een twisted pair vormen.</p>"},{"location":"gwtonn_hardware/bus/#spanning","title":"Spanning","text":"<p>De CAN bus is een bepaald hardware protocol en heeft dus een driver chip nodig. De CAN bus is galvanisch geisoleerd van de modules en heeft dus aparte spanning nodig. Deze spanning is volgens Power-over-Ethernet standaard gestuurd.</p>"},{"location":"gwtonn_hardware/bus/#noodstop","title":"Noodstop","text":"<p>De noodstop is geimplementeerd met twee kabels, spanning en aarde. Op de kop van de bus wordt een spanning gecre\u00eberd, die de hele bus op en neer gaat, om vervolgens in de kop zelf een relais aanstuurt. Alle noodstoppen staan in serie met elkaar en dus als er een wordt ingedrukt, opent de stroomkring zich. Hierdoor opent de relais die de modules </p>"},{"location":"gwtonn_hardware/piggyback/","title":"Basismodule Handleiding","text":"<p>Er is gekozen om een generieke basismodule te maken die voor de meeste applicaties geschikt is. Dit is gedaan om kosten te besparen en programmeergemak te cre\u00ebren. Hieronder bevind zich informatie over deze basismodule en wat er beschikbaar is. Dit bord zal op een draagbord komen wat alle functies daadwerkelijk uitvoert.</p> <p></p>"},{"location":"gwtonn_hardware/piggyback/#benaming","title":"Benaming","text":"<p>Bovenaan de basismodule staan de naam en revisie (Hier \"GWTONN Piggyback R02\") gevolgd door een wit vlak om aan te geven welk nummer het is qua bordje. Mocht er iets kapot zijn aan het bordje kan dit gemarkeerd worden met watervaste stift in het \"AFKEUR\" vakje. Als dit vakje een andere kleur heeft dan wit mag deze niet op de wagen gebruikt worden.</p>"},{"location":"gwtonn_hardware/piggyback/#microcontroller","title":"Microcontroller","text":"<p>De microcontroller is het brein van de hardware. Deze chip voert alle code uit en zorgt dat alle taken gesynchroniseerd uitgevoerd worden. Deze is verantwoordelijk voor bijvoorbeeld lichten precies te schakelen of motoren te laten bewegen.</p>"},{"location":"gwtonn_hardware/piggyback/#status-leds","title":"Status LEDs","text":"<p>Op de basismodule zijn vijf LEDs beschikbaar die ieder een andere functie hebben zoals weergegeven in de tabel hieronder.</p> LED Kleur Functie CAN PWR Groen Geeft aan of de CAN bus stroomtoevoer heeft PWR Groen Geeft aan of de basismodule stroomtoevoer heeft OPER Blauw Geeft aan of de basismodule werkt en operationeel is CAN LINK Blauw Geeft aan of de CAN bus werkt ERROR Rood Geeft aan als iets fout gaat op de basismodule"},{"location":"gwtonn_hardware/piggyback/#ingangen-en-uitgangen","title":"Ingangen en Uitgangen","text":"<p>De basismodule beschikt over twee RJ45/ethernet connectoren om te communiceren met de hoofdmodule en andere basismodules. Daarnaast beschikt dit bord over een normale uitgangsbus (Regular I/O / RIO) en een over hoge snelheidsbus (High Speed I/O / HSIO). Deze uitgangen zijn onder een hoek van 90 graden van elkaar neergezet om te voorkomen dat deze verkeerd om in het draagbord gestoken kan worden. De pin nummeringen zijn weergegeven op de printplaat.</p> <p>Daarnaast beschikt de basismodule over de \"KILLSWITCH\" pinnen. Deze zorgen ervoor dat alle stroom direct van de borden af wordt gegooid als de noodstop ingeduwd wordt.</p> <p>Elk van de pinnen van de normale, en hoge snelheids bus zijn afzonderlijk te besturen. Specifieke pinnen op de bussen kunnen een secundaire functie aanbieden, deze functies zijn te vinden in de datasheet van ST Microelectronics.</p> <p>De \"BOOT MODE\" jumper zorgt ervoor dat de basismodule in primaire of secundaire modus opstart, het verschil hiertussen staat beschreven in de GWTONN Bibliotheek.</p> <p>Er zit ook een microSD kaart lezer op de basismodule. Deze zal het draaiprogramma bevatten en een log schrijven over wat er allemaal gebeurt. De log kan gebruikt worden als evaluatie om te kijken wat er goed en slecht gaat.</p> <p>De reset knop is bedoeld voor tijdens het programmeren of in geval van ernstige fouten die eventueel op te lossen zijn door opnieuw opstarten.</p>"},{"location":"gwtonn_hardware/piggyback/#programmeeruitlees-ingangen-en-uitgangen","title":"Programmeer/Uitlees ingangen en uitgangen","text":"<p>De basismodule bevat een SWD interface (Serial Wire Debug) waarmee de basismodule geprogrammeerd kan worden. Deze interface is te herkennen door de volgende pinnen:</p> <ol> <li>GND</li> <li>SWO</li> <li>SWDIO</li> <li>SWCLK</li> <li>3V3</li> </ol> <p>Hier zijn de 3V3 en GND de 3.3 V voedings pinnen.</p> <p>Als uitleesbus is er in het geval van fouten een UART bus toegevoegd, deze is softwarematig in te stellen naar wens en is te herkennen aan de volgende pinnen:</p> <ol> <li>TX</li> <li>RX</li> <li>3V3</li> <li>GND</li> </ol> <p>Hier zijn de 3V3 en GND de 3.3 V voedings pinnen.</p>"},{"location":"gwtonn_hardware/piggyback/#hoge-snelheidsbus","title":"Hoge snelheidsbus","text":"<p>De pinnen van de microcontroller die gekoppeld zijn aan de hoge snelheidsbus zijn als volgt:</p> HSIO Pin Microcontroller pin 0 PC0 1 PC1 2 PC2 3 PC3 4 PC4 5 PC6 6 PC7 7 PC8 8 PC9 9 PC10 10 PC11 11 PC12 12 PC13"},{"location":"gwtonn_hardware/piggyback/#normale-snelheidsbus","title":"Normale snelheidsbus","text":"<p>De pinnen van de microcontroller die gekoppeld zijn aan de normale snelheidsbus zijn als volgt:</p> RIO Pin Microcontroller pin 0 PA0 1 PA1 2 PA2 3 PA3 4 PA8 5 PA11 6 PA12 7 PA15 8 PB2 9 PB4 10 PB5 11 PB6 12 PB8 13 PB9 14 PB12 15 PB13 16 PB15"},{"location":"gwtonn_hardware/piggyback/#communicatie","title":"Communicatie","text":"<p>De hoofdcommunicatie tussen borden die over heel de wagen verspreid zijn word is een CAN bus. Dit is een robuuste comunicatiebus die onder andere gebruikt word in auto's. Deze bus is elektrisch geisoleerd van de rest van de basismodule. Dit is gedaan omdat in het geval er een andere basismodule catastrofaal beschadigd niet alle bordjes beschadigen. Meer informatie over het gebruik van de bus is te vinden onder het kopje Busarchitectuur.</p>"},{"location":"software/","title":"Software","text":"<p>Voor het schrijven van de software is er voor gekozen om de firmware (aansturing van de hardware) te scheiden van het programma. </p> <p>Hierbij gelden de volgende definities:</p> Component Omschrijving Meer info Firmware De code die op alle piggyback hetzelfde is. Dit vormt de laag naar de hardware en voert het programma stap voor stap uit Firmware Programma Dit is de set van instructies die een piggyback moet uitvoeren op de dag van de optocht. Deze is eenvoudig te programmeren en kan makkelijk geladen worden vanaf een SD Card Programma"},{"location":"software/#verantwoording","title":"Verantwoording","text":"<p>Er is voor dit onderscheid gekozen voor verschillende reden:</p> <ol> <li>Het is eenvoudiger om in het Nederlands een programma te maken</li> <li>Het programma is vaak niet meer als het aanzetten van een output, wachten en weer intrekken. De hele firmware specifiek maken is dan complex voor deze taak</li> <li>Op de bouw is het eenvoudiger een SD Card te vervangen dan een volledige flash uit te voeren.</li> </ol>"},{"location":"software/firmware/","title":"Ge Wit't Oit Noit Nie Firmware","text":"<p>Om het overzichtelijk te houden, is er een losse bibliotheek gemaakt voor Ge Wit't Oit Noit Nie. De bibliotheek is te vinden in <code>{workspace}/Middlewares/gwtonn</code>.</p>"},{"location":"software/firmware/#programma-controller","title":"Programma controller","text":"<p>Voor het uitvoeren van de programma, is er een programma controller. De details staan beschreven in programma controller.</p>"},{"location":"software/firmware/#logger-freertos-implementation","title":"Logger - FreeRTOS implementation","text":"<p>De <code>logger</code> implementeerd functionaliteiten om een log te schrijven op een SD kaart (Via de SPI Interface).</p> <p>De <code>void start_logger(void *argument)</code> is geimplementeerd in the bilbiotheek. De functie is <code>__weak</code> gemaakt in <code>freertos.c</code>. Om dit te laten werken, is in de STM32CubeMX programma een FreeRTOS taak gemaakt met de naam logTask en de functie <code>start_logger</code>. De Code Generation Option is ingesteld op As Weak.</p> <p>Voor details over de logger, kijk in de hoofdstuk over de logger.</p>"},{"location":"software/firmware/#message-mechanisme","title":"Message mechanisme","text":"<p>Om een berichte te schrijven op de SD kaart, kan een specifieke wachtrij gevuld worden. Deze rij heet loggerQueue. De queue wordt uitmatisch gemaakt bij het schrijven van de broncode vanuit STM32CubeMX.</p> <p>Om een bericht te sturen moet je <code>sd_logger.h</code> laden in de c code. Daarna kan de volgende code toegevoegd worden:</p> <pre><code> MSGQUEUE_OBJ_t msg;\n\nmsg.index=1;\nmsg.message = 'A';\nosMessageQueuePut(loggerQueueHandle, &amp;msg, 0, 0U);\n</code></pre>"},{"location":"software/firmware/#fatfs-met-de-sd-card-controller-via-spi","title":"FatFS met de SD Card Controller via SPI","text":"<p>Om bestanden te kunnen maken op een SD kaart, gebruiken we een SD Card reader. Deze wordt aangesloten via een SPI Interface met de Nucleo board. Vervolgens gebruiken we de FatFS library om een bestandsysteem te simuleren.</p> <p>De FatFS staat aangemerkt als <code>USER_Driver</code> in STM32CubeMX. Deze userdriver is gedefineerd in user_diskio.h en geimplementeerd in  user_diskio.c.</p> <p>De vertaalslag van de FATFS implentatie naar SPI commando's gebeurt in fatfs_sd.c.</p>"},{"location":"software/firmware/can/","title":"CAN","text":"<p>t.b.d.</p>"},{"location":"software/firmware/logger/","title":"Logger","text":"<p>De logger wordt gebruikt om cruciale informatie op te slaan over de staat van de STM32 en het programma.</p>"},{"location":"software/firmware/logger/#voorbeeld","title":"Voorbeeld","text":"<p>Kijk naar de volgende entry:</p> <pre><code>[13:18:16],16,3,9,64100,149\n</code></pre> <p>De volgende gegevens worden weergegeven:</p> <ul> <li>[13:18:16]: Tijd van het bericht</li> <li>16: Bericht soort (MSG_PROGRAM_COUNTER)</li> <li>3: instruction_pointer op moment van loggen</li> <li>9: shutdown_index op moment van loggen</li> <li>64100: Interne temperatuur van de STM32</li> <li>149: Actuele voltage op moment van schrijven van de STM32</li> </ul>"},{"location":"software/firmware/logger/#logbericht-sturen","title":"Logbericht sturen","text":"<p>Om een bericht te loggen dient er een bericht op de queue gezet te worden. Volgende stukje code is een voorbeeld:</p> <pre><code>MSGQUEUE_OBJ_t msg = {\n    MSG_PROGRAM_COUNTER,\n    pcr.instruction_pointer,\n    pcr.shutdown_instruction_pointer,\n    get_temperature(),\n    get_vref(),\n    };\nif (osOK != osMessageQueuePut(loggerQueueHandle, &amp;msg, 0, 0U))\n{\n    printf(\"Error: Could not send message to loggerQueueHandle\\n\\r\");\n}\n</code></pre> <p>Zoals je kan zien wordt er eerst een bericht aangemaakt. Daarna wordt deze op de queue gezet (<code>loggerQueueHandle</code>). Voor de exacte details van het queue mechanisme kan je kijken bij ST.</p>"},{"location":"software/firmware/logger/#log-bericht","title":"Log bericht","text":"<p>Voor het versturen van een log bericht wordt gebruik gemaakt van een structure. </p> <pre><code>typedef struct\n{\n    uint8_t message;\n    uint32_t program_counter;\n    uint16_t shutdown_index_register;\n    uint16_t temperature;\n    uint16_t vrefint;\n} MSGQUEUE_OBJ_t;\n</code></pre> <p>Hiervoor geld de volgende definitie:</p> Kolom Type Omschrijving message uint8_t Een waarde die aangeeft wat het bericht betekened (MSG_PROGRAM_COUNTER) program_counter uint32_t De huidige waare van de instruction_pointer shutdown_index_register uint16_t De huidige waarde van de shutdown_index_register temperature uint16_t De huidige temperatuur van de STM32 in graden celcius * 1000 vrefint uint16_t De huidige voltage van de STM32 in mV"},{"location":"software/firmware/programma_controller/","title":"Programma","text":"<p>Het hele idee van de controller is om een progarmma uit te voeren. Op deze pagina beschrijven hoe dit werkt.</p>"},{"location":"software/firmware/programma_controller/#programmeren","title":"Programmeren","text":"<p>Voor het programmeren is een eigen ontwikkeltaal gemaakt. Deze hier beschreven: programma speccificatie. Na het programmeren moet het programma gecompileerd worden.</p> <p>Na het compileren moet de programma geschreven worden in het geheugen. Dat kan op 2 manieren zoals beschreven in de volgende paragrafen.</p>"},{"location":"software/firmware/programma_controller/#programma-laden-in-de-firmware","title":"Programma laden in de firmware","text":"<p>De eerste methode is het laden van het programma in de firmware. In basis kan hiervoor de volgende stappenplan gevolgt worden:</p> <ol> <li>Schrijf een programma.</li> <li>Compileer het programma met de gpc</li> <li>Copieer het bestand dat gemaakt is als output naar de root van de firmware folder</li> <li>Zorg er voor dat het programma <code>binary_file.bin</code> heet</li> <li>Compileer en laad de firmware</li> </ol>"},{"location":"software/firmware/programma_controller/#programma-laden-via-de-sd-card","title":"Programma laden via de SD Card","text":"<p>Een andere mogelijkheid is het laden van een programma via de SD Card. Hiervoor dient een bestand met de name <code>binary_file.bin</code> in de root van de SD Card staan. Volg de volgende stappen:</p> <ol> <li>Schrijf een programma.</li> <li>Compileer het programma met de gpc</li> <li>Copieer het bestand dat gemaakt is als output naar de root van een SD Card</li> <li>Zorg er voor dat het programma <code>binary_file.bin</code> heet</li> <li>de SD Card moet FAT32 geformateerd zijn</li> <li>Herstart de STM32 piggybord.</li> </ol>"},{"location":"software/gpc/","title":"GPC","text":"<p>De Ge Wit't Oit Noit Nie Programma Compiler!</p>"},{"location":"software/gpc/#programma","title":"Programma","text":"<p>Een programma wordt geschreven in een textfile. Deze kan een willekeurige extentie hebben, maar <code>.gpc</code> is de standaard. Een programma bestaat uit een instructie per regel. Iedere regel wordt afgesloten met een ';'.</p> <p>In principe heeft een instructie 0, 1, 2 of 3 parameters. Iedere parameter wordt voorzien van de volgende structuur: <code>&lt;&lt;INSTRUCTIE&gt;&gt; (&lt;&lt;PARAM&gt;&gt;);</code>.</p> <p>Wanneer een parameter gezet wordt, dan bestaad deze uit een identifier en een numerieke waarde.</p>"},{"location":"software/gpc/#numerieke-waarde","title":"Numerieke waarde","text":"<p>In een programma kan gebruikt worden van een numerieke waarde.  Deze waarde kan opgegeven worden in Hexadecimaal, binair en decimaal.</p> <p>Standaard wordt decimaal gebruikt: 123.</p> <p>Wanneer er gebruik gemaakt wordt van hexadecimaal, dan wordt de  waarde voorzien van de prefic: <code>0x</code>. Het getal wordt vervolgens  geschreven met normale hexadecimale getallen: 0-9A-F.</p> <p>Voor het gebruik van een binair getal wordt de prefix <code>0b</code> gebruikt. De waarde wordt dan gezet met behulp van 1 en 0.</p> <p>De volgende getallen zijn dan allemaal hetzelfde:</p> <ul> <li>163</li> <li>0xA3</li> <li>0b10100011</li> </ul>"},{"location":"software/gpc/#voorbeeld","title":"Voorbeeld","text":"<p>Bekijk het volgende voorbeeld</p> <pre><code>BEGIN_EINDE_PROGRAMMA_INDEX (index=0x0007);\nZET_PORT_AAN (PORTNR=0x00, HSIO=0x00);\nZET_PORT_UIT (PORTNR=0x01, HSIO=0x00);\nWACHTEN (delay=0x05DC);\nFLIP_POORT (PORTNR=0x01, HSIO=1);\nBEWAAR_STATUS;\nSPRING (index=0x0003);\nBEWAAR_STATUS;\nSTOPPEN;\n</code></pre> <p>In dit programma, worden de volgende stappen uitgevoerd:</p> <ol> <li>Bewaar de positie van voor het einde van de programma (instructie 8)</li> <li>Wacht voor 1500ms</li> <li>Zet de IO port 1 op hoog</li> <li>Zet de IO port 1 op laag</li> <li>Flip de high-speed IO port 1</li> <li>bewaar de status (telemetry)</li> <li>spring terug naar de 2de instructie</li> <li>stop het programma</li> </ol>"},{"location":"software/gpc/#compileren","title":"Compileren","text":"<p>Start een python sessie en type het volgende</p> <pre><code>python src/gpc.py -i &lt;input_file&gt; -o &lt;output_file&gt; -v\n</code></pre> <p>Met de volgende parameters:</p> <ul> <li>-i, --input: de broncode die gecompileerd moet worden</li> <li>-o, --output: het .bin bestand dat gemaakt wordt</li> <li>-v, --verbose: Volg de uitput</li> </ul>"},{"location":"software/gpc/#binair-bestand","title":"Binair bestand","text":"<p>De output van de compiler is een binair bestand. Deze kan met speciale progarmma's gelezen worden. VSCode met een HEX Editor plugin kan dit bestand gelezen worden.</p> <p>Note</p> <p>Het bestand wordt geschreven in een big-endian setup. Dit houdt in dat per byte de eerste 4 bits als laatste geschreven worden. Bijvoorbeeld <code>WACHTEN(INDEX=1500);</code> wordt vertaald naar <code>0x25DC</code>. Het wordt vervolgens geschreven als <code>DC 25</code>.</p>"},{"location":"software/gpc/#toevoegen-aan-de-firmware","title":"Toevoegen aan de firmware","text":"<p>Voor het gebruik van het programma in de firmware:</p> <ol> <li>copieer het bestand <code>binary_file.bin</code> naar de repository 2025-software in de root.</li> <li>Maak de cache voor <code>CMake</code> leeg een compileer de firmware.</li> <li>Upload de firmware.</li> </ol>"},{"location":"software/gpc/#voorbeeld_1","title":"Voorbeeld","text":"<pre><code>python src/gpc.py -i .\\examples\\simpel_programma_2.gpc -o .\\binary_file.bin -v\n</code></pre>"},{"location":"software/gpc/#python-starten","title":"Python starten","text":"<p>Voor de compiler gebruiken we een virtuele python omgeving.</p> <pre><code>.\\.venv\\Scripts\\activate.ps1\n</code></pre>"},{"location":"software/gpc/#virtual-env-aanmaken","title":"Virtual env aanmaken","text":"<p>Dit kan gedaan worden met de volgende commande:</p> <pre><code>python -m venv .venv\n</code></pre>"},{"location":"software/gpc/program_specifications/","title":"Instructieset","text":"<p>De volgende instructies zijn beschikbaar:</p> <ul> <li>STOPPEN</li> <li>BEGIN_EINDE_PROGRAMMA_INDEX</li> <li>Wachten</li> <li>ZET_PORT_AAN</li> <li>ZET_PORT_UIT</li> <li>FLIP_POORT</li> <li>BEWAAR_STATUS</li> <li>SPRING</li> </ul>"},{"location":"software/gpc/program_specifications/#stoppen","title":"STOPPEN","text":"<p>De functie STOPPEN wordt als volgt gecodeerd:</p> Element Bitmask Hex Parameter OPCODE 0b0000 0000 0000 0000 0x0000 <p>Deze functie is by default ingevult in het geheugen.</p>"},{"location":"software/gpc/program_specifications/#voorbeeld","title":"Voorbeeld","text":"<pre><code>STOPPEN;\n</code></pre>"},{"location":"software/gpc/program_specifications/#begin_einde_programma_index","title":"BEGIN_EINDE_PROGRAMMA_INDEX","text":"<p>De functie BEGIN_EINDE_PROGRAMMA_INDEX wordt als volgt gecodeerd:</p> Element Bitmask Hex Parameter OPCODE 0b0001 0000 0000 0000 0x1000 DELAY 0b0000 1111 1111 1111 0x0FFF INDEX <p>De maximale index is dus 4095</p>"},{"location":"software/gpc/program_specifications/#voorbeeld_1","title":"Voorbeeld","text":"<pre><code>BEGIN_EINDE_PROGRAMMA_INDEX(INDEX=0x0011);\n</code></pre>"},{"location":"software/gpc/program_specifications/#wachten","title":"Wachten","text":"<p>De functie WACHTEN wordt als volgt gecodeerd:</p> Element Bitmask Hex Parameter OPCODE 0b0010 0000 0000 0000 0x2000 DELAY 0b0000 1111 1111 1111 0x0FFF DELAY <p>De maximale delay is dus 4095 ms</p>"},{"location":"software/gpc/program_specifications/#voorbeeld_2","title":"Voorbeeld","text":"<pre><code>WACHTEN(INDEX=1500);\n</code></pre>"},{"location":"software/gpc/program_specifications/#zet_port_aan","title":"ZET_PORT_AAN","text":"<p>De functie ZET_PORT_AAN wordt als volgt gecodeerd:</p> Element Bitmask Hex Parameter OPCODE 0b0011 0000 0000 0000 0x3000 HSIO 0b0000 0010 0000 0000 0x0200 HSIO (0x0 / 0x01) HIGH 0b0000 0001 0000 0000 0x0100 PORT 0b0000 0000 0001 1111 0x001F PORTNR <p>De PORT is een van de 13 (0-12) gewone IO Poorten of 0-8 HSIO poorten.</p>"},{"location":"software/gpc/program_specifications/#voorbeeld_3","title":"Voorbeeld","text":"<pre><code>ZET_PORT_AAN (PORTNR=0x00, HSIO=0x00);\n</code></pre>"},{"location":"software/gpc/program_specifications/#zet_port_uit","title":"ZET_PORT_UIT","text":"<p>De functie ZET_PORT_AAN wordt als volgt gecodeerd:</p> Element Bitmask Hex Parameter OPCODE 0b0100 0000 0000 0000 0x4000 HSIO 0b0000 0010 0000 0000 0x0200 HSIO (0x0 / 0x01) HIGH 0b0000 0001 0000 0000 0x0100 PORT 0b0000 0000 0001 1111 0x001F PORTNR <p>De PORT is een van de 13 (0-12) gewone IO Poorten of 0-8 HSIO poorten.</p>"},{"location":"software/gpc/program_specifications/#voorbeeld_4","title":"Voorbeeld","text":"<pre><code>ZET_PORT_UIT (PORTNR=0x00, HSIO=0x00);\n</code></pre>"},{"location":"software/gpc/program_specifications/#flip_poort","title":"FLIP_POORT","text":"<p>De functie FLIP_POORT wordt als volgt gecodeerd:</p> Element Bitmask Hex Parameter OPCODE 0b0101 0000 0000 0000 0x5000 HSIO 0b0000 0010 0000 0000 0x0200 HSIO (0x0 / 0x01) PORT 0b0000 0000 0001 1111 0x001F PORTNR <p>De PORT is een van de 13 (0-12) gewone IO Poorten of 0-8 HSIO poorten.</p>"},{"location":"software/gpc/program_specifications/#voorbeeld_5","title":"Voorbeeld","text":"<pre><code>FLIP_POORT (PORTNR=0x01, HSIO=1);\n</code></pre>"},{"location":"software/gpc/program_specifications/#bewaar_status","title":"BEWAAR_STATUS","text":"<p>De functie BEWAAR_STATUS wordt als volgt gecodeerd:</p> Element Bitmask Hex Parameter OPCODE 0b0110 0000 0000 0000 0x6000"},{"location":"software/gpc/program_specifications/#voorbeeld_6","title":"Voorbeeld","text":"<pre><code>BEWAAR_STATUS;\n</code></pre>"},{"location":"software/gpc/program_specifications/#spring","title":"SPRING","text":"<p>De functie BEWAAR_STATUS wordt als volgt gecodeerd:</p> Element Bitmask Hex Parameter OPCODE 0b0110 0000 0000 0000 INDEX 0b0000 1111 1111 1111 x0FFF Spring direct naar index"},{"location":"software/gpc/program_specifications/#voorbeeld_7","title":"Voorbeeld","text":"<pre><code>SPRING (index=0x0003);\n</code></pre>"},{"location":"year/2025/about/","title":"Over 2025","text":"<p>Hier komt een beschrijving van de setup voor 2025.</p>"},{"location":"year/2025/about/#hardware-setup","title":"Hardware setup","text":"<p>[!NOTE] Maak een schema met de verschillende componenten</p>"},{"location":"year/2025/about/#component-1","title":"Component 1","text":""},{"location":"year/2025/about/#component-2","title":"Component 2","text":""},{"location":"year/2025/about/#programma","title":"Programma","text":"<p>Beschrijf hier de programma die uitgevoerd moet worden in simpele stappen.</p> <p>Voeg eventueel een tekening toe met uml:</p> <pre><code>@startuml\n\nstart\n  :store exit index;\nrepeat\n  :zet motor in vooruit;\n  :start motor;\n  :wacht voor 3 seconden;\n  :stop motor;\n  :wacht voor 4 seconden;\n  :zet motor in reverse;\n  :start motor;\n  :wacht voor 3 seconden;\n  :stop motor;\nrepeat while (more data?) is (yes) not (no)\n  :zet motor in reverse;\n  :start motor;\n  :wacht voor 4 seconden;\n  :stop motor;\n\nstop\n@enduml\n</code></pre>"},{"location":"year/2025/program_specifications/","title":"Programnma specificaties","text":""},{"location":"year/2025/program_specifications/#pins-functies","title":"Pins &amp; Functies","text":"<ul> <li>USART3: Serial port voor sturen van informatie</li> <li>SYS: Debug: Serial wire, Timebase Source: TIM1</li> <li>RCC: High speed clock and low speed clock based on cristals build in  </li> <li>SPI1: SD Card writer over SPI</li> <li>EXTI line 1: Voor interrupt</li> <li>EXTI line 15: Voor interrupt</li> </ul>"},{"location":"year/2025/program_specifications/#pins","title":"PINS","text":"PIN Assignment PA4 SPI1_CS PA5 SPI1_SCK PA6 SPI1_MISO PA7 SPI1_MOSI PA13 SYS_JTMS-SWDIO PA14 SYS_JTMS-SWCLK PB0 LED 1 [Green] - DefaultTask running PB1 GPIO External Interrupt mode with Rise Edge trigger detection - Emergency button PB3 SYT_JTDO-SWO PB7 LED 2 [Blue] PB14 LED 3 [Red] - HardFault_Handler entered PC14 RCC_OSC32 PC15 RCC_OSC32_OUT PD8 UART3_TX PD9 UART3_RX PH0 RCC_OSC_IN PH1 RCC_OSC_OUT"}]}